

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Setup &mdash; mpire 1.2.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/banner.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinxcontrib-images/LightBox2/lightbox2/css/lightbox.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/sphinxcontrib-images/LightBox2/lightbox2/js/jquery-1.11.0.min.js"></script>
        <script src="../_static/sphinxcontrib-images/LightBox2/lightbox2/js/lightbox.min.js"></script>
        <script src="../_static/sphinxcontrib-images/LightBox2/lightbox2-customize/jquery-noconflict.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Map family" href="map.html" />
    <link rel="prev" title="Usage" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> mpire
          

          
          </a>

          
            
            
              <div class="version">
                1.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to the MPIRE documentation!</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Usage</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="map.html">Map family</a></li>
<li class="toctree-l2"><a class="reference internal" href="dashboard.html">Dashboard</a></li>
<li class="toctree-l2"><a class="reference internal" href="known_issues.html">Known issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">mpire</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Usage</a> &raquo;</li>
        
      <li>Setup</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/usage/setup.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="setup">
<h1>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h1>
<p>This section describes the different ways of creating a <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> object.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#starting-a-workerpool" id="id1">Starting a WorkerPool</a></p></li>
<li><p><a class="reference internal" href="#nested-workerpools" id="id2">Nested WorkerPools</a></p></li>
<li><p><a class="reference internal" href="#cpu-pinning" id="id3">CPU pinning</a></p></li>
<li><p><a class="reference internal" href="#shared-objects" id="id4">Shared objects</a></p></li>
<li><p><a class="reference internal" href="#worker-state" id="id5">Worker state</a></p></li>
<li><p><a class="reference internal" href="#accessing-the-worker-id" id="id6">Accessing the worker ID</a></p></li>
<li><p><a class="reference internal" href="#process-start-method" id="id7">Process start method</a></p></li>
<li><p><a class="reference internal" href="#keep-alive" id="id8">Keep alive</a></p></li>
</ul>
</div>
<section id="starting-a-workerpool">
<h2><a class="toc-backref" href="#id1">Starting a WorkerPool</a><a class="headerlink" href="#starting-a-workerpool" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> class controls a pool of worker processes similarly to a <code class="docutils literal notranslate"><span class="pre">multiprocessing.Pool</span></code>. It
contains all the <code class="docutils literal notranslate"><span class="pre">map</span></code> like functions (with the addition of <a class="reference internal" href="../reference/index.html#mpire.WorkerPool.map_unordered" title="mpire.WorkerPool.map_unordered"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpire.WorkerPool.map_unordered()</span></code></a>), but currently
lacks the <code class="docutils literal notranslate"><span class="pre">apply</span></code> and <code class="docutils literal notranslate"><span class="pre">apply_async</span></code> functions (if you wish to add it, feel free to do so).</p>
<p>An <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> can be started in two different ways. The first and recommended way to do so is using a
context manager:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mpire</span> <span class="kn">import</span> <span class="n">WorkerPool</span>

<span class="c1"># Start a pool of 4 workers</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="c1"># Do some processing here</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">with</span></code> statement takes care of properly joining/terminating the spawned worker processes after the block has
ended.</p>
<p>The other way is to do it manually:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Start a pool of 4 workers</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Do some processing here</span>
<span class="k">pass</span>

<span class="c1"># Clean up pool (this will block until all processing has completed)</span>
<span class="n">pool</span><span class="o">.</span><span class="n">stop_and_join</span><span class="p">()</span>

<span class="c1"># In the case you want to kill the processes even though they are still busy</span>
<span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</pre></div>
</div>
<p>When using <code class="docutils literal notranslate"><span class="pre">n_jobs=None</span></code> MPIRE will spawn as many processes as there are CPUs on your system. Specifying more jobs
than you have CPUs is, of course, possible as well.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The results queue should be drained first before joining the workers, otherwise you can get a deadlock. If you want
to join either way, use <a class="reference internal" href="../reference/index.html#mpire.WorkerPool.terminate" title="mpire.WorkerPool.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpire.WorkerPool.terminate()</span></code></a>. For more information, see the warnings in the Python
docs <a class="reference external" href="https://docs.python.org/3.4/library/multiprocessing.html#pipes-and-queues">here</a>.</p>
</div>
</section>
<section id="nested-workerpools">
<h2><a class="toc-backref" href="#id2">Nested WorkerPools</a><a class="headerlink" href="#nested-workerpools" title="Permalink to this headline">¶</a></h2>
<p>Normally, the <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> class spawns daemon child processes who are not able to create child processes
themselves, so nested pools are not allowed. However, there’s an option to create normal child processes, instead of
daemon, to allow for nested structures:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">job</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
        <span class="c1"># Do some work</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="c1"># This will raise an AssertionError telling you daemon processes can&#39;t start child processes</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>

<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="c1"># This will work just fine</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Do make sure all your non-daemon processes are terminated correctly. If a nested child process is interrupted, for
example when the user triggers a <code class="docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code>, the process will remain active and will have to be terminated
manually.</p>
</section>
<section id="cpu-pinning">
<h2><a class="toc-backref" href="#id3">CPU pinning</a><a class="headerlink" href="#cpu-pinning" title="Permalink to this headline">¶</a></h2>
<p>If desired you can pin the child processes of <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> to specific CPUs by using the <code class="docutils literal notranslate"><span class="pre">cpu_ids</span></code>
parameter in the constructor:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Pin the two child processes to CPUs 2 and 3</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cpu_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># Pin the child processes to CPUs 40-59</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">cpu_ids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">60</span><span class="p">)))</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># All child processes have to share a single core:</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">cpu_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># All child processes have to share multiple cores, namely 4-7:</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">cpu_ids</span><span class="o">=</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># Each child process can use two distinctive cores:</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">cpu_ids</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>CPU IDs have to be positive integers, not exceeding the number of CPUs available (which can be retrieved by using
<code class="docutils literal notranslate"><span class="pre">mpire.cpu_count()</span></code>). Use <code class="docutils literal notranslate"><span class="pre">None</span></code> to disable CPU pinning (which is the default).</p>
</section>
<section id="shared-objects">
<h2><a class="toc-backref" href="#id4">Shared objects</a><a class="headerlink" href="#shared-objects" title="Permalink to this headline">¶</a></h2>
<p>MPIRE allows you to provide shared objects to the workers in a similar way as is possible with the
<code class="docutils literal notranslate"><span class="pre">multiprocessing.Process</span></code> class. These shared objects are treated as <code class="docutils literal notranslate"><span class="pre">copy-on-write</span></code>, they are only copied once
changes are made to them, otherwise they share the same memory address. This is convenient if you want to let workers
access a large dataset that wouldn’t fit in memory when copied multiple times. When shared objects are copied they are
only copied once for each worker, in contrast to copying it for each task which is done when using a regular
<code class="docutils literal notranslate"><span class="pre">multiprocessing.Pool</span></code>.</p>
<p>By using a <code class="docutils literal notranslate"><span class="pre">multiprocessing.Array</span></code>, <code class="docutils literal notranslate"><span class="pre">multiprocessing.Value</span></code>, or another object with <code class="docutils literal notranslate"><span class="pre">multiprocessing.Manager</span></code> you
could even store results in the same object from multiple processes. However, be aware of the possible locking behavior
that comes with it. However, in some cases you can safely disable locking, as is shown here:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Array</span>

<span class="k">def</span> <span class="nf">square_with_index</span><span class="p">(</span><span class="n">shared_objects</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># Even though the shared objects is a single container, we &#39;unpack&#39; it</span>
    <span class="c1"># (only to be consistent with the function below)</span>
    <span class="n">results_container</span> <span class="o">=</span> <span class="n">shared_objects</span>

    <span class="c1"># Square</span>
    <span class="n">results_container</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">square_add_and_modulo_with_index</span><span class="p">(</span><span class="n">shared_objects</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># Unpack results containers</span>
    <span class="n">square_results_container</span><span class="p">,</span> <span class="n">add_results_container</span> <span class="o">=</span> <span class="n">shared_objects</span>

    <span class="c1"># Square, add and modulo</span>
    <span class="n">square_results_container</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
    <span class="n">add_results_container</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span>


<span class="c1"># 1. Use a shared array of size 100 and type float to store the results</span>
<span class="n">results_container</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shared_objects</span><span class="o">=</span><span class="n">results_container</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>

    <span class="c1"># Square the results and store them in the results container</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map_unordered</span><span class="p">(</span><span class="n">square_with_index</span><span class="p">,</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)),</span>
                       <span class="n">iterable_len</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="c1"># 2, Use a shared array of size 100 and type float to store the results</span>
<span class="n">square_results_container</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">add_results_container</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                <span class="n">shared_objects</span><span class="o">=</span><span class="p">(</span><span class="n">square_results_container</span><span class="p">,</span> <span class="n">add_results_container</span><span class="p">))</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>

    <span class="c1"># Square, add and modulo the results and store them in the results containers</span>
    <span class="n">modulo_results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">square_add_and_modulo_with_index</span><span class="p">,</span>
                              <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)),</span> <span class="n">iterable_len</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Multiple objects can be provided by placing them, for example, in a tuple container as is done in example two above.
When providing shared objects the provided function pointer in the map functions should receive the shared objects as
its first argument (or the second argument when the worker ID is passed on as well, see <a class="reference internal" href="#workerid"><span class="std std-ref">Accessing the worker ID</span></a>).</p>
<p>In the first example (marked <code class="docutils literal notranslate"><span class="pre">#1</span></code>) we create a results container and disable locking. We can safely disable locking
here as each task writes to a different index in the array, so no race conditions can occur. Disabling locking is, of
course, a lot faster than enabling it.</p>
<p>In the second example we create two different results containers, one for squaring and for adding the given value.
Additionally, we also return a value, even though we use shared objects for storing results.</p>
<p>Instead of passing the shared objects to the <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> constructor you can also use the
<a class="reference internal" href="../reference/index.html#mpire.WorkerPool.set_shared_objects" title="mpire.WorkerPool.set_shared_objects"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpire.WorkerPool.set_shared_objects()</span></code></a> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">results_container</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">set_shared_objects</span><span class="p">(</span><span class="n">results_container</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map_unordered</span><span class="p">(</span><span class="n">square_with_index</span><span class="p">,</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)),</span>
                       <span class="n">iterable_len</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="worker-state">
<h2><a class="toc-backref" href="#id5">Worker state</a><a class="headerlink" href="#worker-state" title="Permalink to this headline">¶</a></h2>
<p>If you want to let each worker have its own state you can use the <code class="docutils literal notranslate"><span class="pre">use_worker_state</span></code> flag:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">def</span> <span class="nf">load_big_model</span><span class="p">():</span>
    <span class="c1"># Load a model which takes up a lot of memory</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;./a_really_big_model.p3&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">model_predict</span><span class="p">(</span><span class="n">worker_state</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># Load model</span>
    <span class="k">if</span> <span class="s1">&#39;model&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">worker_state</span><span class="p">:</span>
        <span class="n">worker_state</span><span class="p">[</span><span class="s1">&#39;model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">load_big_model</span><span class="p">()</span>

    <span class="c1"># Predict</span>
    <span class="k">return</span> <span class="n">worker_state</span><span class="p">[</span><span class="s1">&#39;model&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">use_worker_state</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="c1"># Let the model predict</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">...</span><span class="p">]])</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">model_predict</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Instead of passing the flag to the <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> constructor you can also make use of
<a class="reference internal" href="../reference/index.html#mpire.WorkerPool.set_use_worker_state" title="mpire.WorkerPool.set_use_worker_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpire.WorkerPool.set_use_worker_state()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">set_use_worker_state</span><span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">model_predict</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="accessing-the-worker-id">
<span id="workerid"></span><h2><a class="toc-backref" href="#id6">Accessing the worker ID</a><a class="headerlink" href="#accessing-the-worker-id" title="Permalink to this headline">¶</a></h2>
<p>Each worker in MPIRE is given an integer ID to distinguish them. Worker #1 will have ID <code class="docutils literal notranslate"><span class="pre">0</span></code>, #2 will have ID <code class="docutils literal notranslate"><span class="pre">1</span></code>,
etc. Sometimes it can be useful to have access to this ID. For example, when you have a shared array of which the size
equals the number of workers and you want worker #1 only to access the first element, and worker #2 only to access the
second element, and so on.</p>
<p>By default, the worker ID is not passed on. You can enable/disable this by setting the <code class="docutils literal notranslate"><span class="pre">pass_worker_id</span></code> flag:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">square_sum</span><span class="p">(</span><span class="n">worker_id</span><span class="p">,</span> <span class="n">shared_objects</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># Even though the shared objects is a single container, we &#39;unpack&#39; it anyway</span>
    <span class="n">results_container</span> <span class="o">=</span> <span class="n">shared_objects</span>

    <span class="c1"># Square and sum</span>
    <span class="n">results_container</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1"># Use a shared array of size equal to the number of jobs to store the results</span>
<span class="n">results_container</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shared_objects</span><span class="o">=</span><span class="n">results_container</span><span class="p">,</span> <span class="n">pass_worker_id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="c1"># Square the results and store them in the results container</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map_unordered</span><span class="p">(</span><span class="n">square_sum</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
<p>The worker ID will always be the first passed on argument to the provided function pointer.</p>
<p>Instead of passing the flag to the <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> constructor you can also make use of
<a class="reference internal" href="../reference/index.html#mpire.WorkerPool.pass_on_worker_id" title="mpire.WorkerPool.pass_on_worker_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpire.WorkerPool.pass_on_worker_id()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shared_objects</span><span class="o">=</span><span class="n">results_container</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">pass_on_worker_id</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map_unordered</span><span class="p">(</span><span class="n">square_sum</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="process-start-method">
<h2><a class="toc-backref" href="#id7">Process start method</a><a class="headerlink" href="#process-start-method" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> package allows you to start processes using a few different methods: <code class="docutils literal notranslate"><span class="pre">'fork'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'forkserver'</span></code>. Threading is also available by using <code class="docutils literal notranslate"><span class="pre">'threading'</span></code>. For detailed information on the multiprocessing
contexts, please refer to the multiprocessing <a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods">documentation</a> and <a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods">caveats</a> section. In short:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'fork'</span></code> (the default) copies the parent process such that the child process is effectively identical. This
includes copying everything currently in memory. This is sometimes useful, but other times useless or even a serious
bottleneck.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'spawn'</span></code> starts a fresh python interpreter where only those resources necessary are inherited.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'forkserver'</span></code> first starts a server process. Whenever a new process is needed the parent process requests the
server to fork a new process.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'threading'</span></code> starts child threads.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code> and <code class="docutils literal notranslate"><span class="pre">'forkserver'</span></code> methods have some <a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods">caveats</a>. All resources needed for running the child process
should be picklable. This can sometimes be a hassle when you heavily rely on lambdas or are trying to run MPIRE in an
interactive shell. To remedy most of these problems MPIRE can use <a class="reference external" href="https://pypi.org/project/dill/">dill</a> as a replacement for pickle. Simply install the
required <a class="reference internal" href="../install.html#dilldep"><span class="std std-ref">dependencies</span></a> and you’re good to go.</p>
<p>Additionally, global variables (constants are fine) might have a different value than you might expect. You also have to
import packages within the called function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">failing_job</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

<span class="c1"># This will fail because &#39;os&#39; is not copied to the child processes</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">start_method</span><span class="o">=</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">failing_job</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;folder&#39;</span><span class="p">,</span> <span class="s1">&#39;0.p3&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;folder&#39;</span><span class="p">,</span> <span class="s1">&#39;1.p3&#39;</span><span class="p">)])</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">working_job</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

<span class="c1"># This will work</span>
<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">start_method</span><span class="o">=</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">working_job</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;folder&#39;</span><span class="p">,</span> <span class="s1">&#39;0.p3&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;folder&#39;</span><span class="p">,</span> <span class="s1">&#39;1.p3&#39;</span><span class="p">)])</span>
</pre></div>
</div>
</section>
<section id="keep-alive">
<h2><a class="toc-backref" href="#id8">Keep alive</a><a class="headerlink" href="#keep-alive" title="Permalink to this headline">¶</a></h2>
<p>Workers can be kept alive in between consecutive map calls using the <code class="docutils literal notranslate"><span class="pre">keep_alive</span></code> flag. This is useful when your
workers have a long startup time and you need to call one of the map functions multiple times. When either the function
to execute or the <code class="docutils literal notranslate"><span class="pre">worker_lifespan</span></code> parameter changes MPIRE will ignore the flag as it needs to restart the workers.</p>
<p>Building further on the worker state example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">def</span> <span class="nf">load_big_model</span><span class="p">():</span>
    <span class="c1"># Load a model which takes up a lot of memory</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;./a_really_big_model.p3&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">model_predict</span><span class="p">(</span><span class="n">worker_state</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># Load model</span>
    <span class="k">if</span> <span class="s1">&#39;model&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">worker_state</span><span class="p">:</span>
        <span class="n">worker_state</span><span class="p">[</span><span class="s1">&#39;model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">load_big_model</span><span class="p">()</span>

    <span class="c1"># Predict</span>
    <span class="k">return</span> <span class="n">worker_state</span><span class="p">[</span><span class="s1">&#39;model&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">use_worker_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keep_alive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="c1"># Let the model predict</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">...</span><span class="p">]])</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">model_predict</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># Do something with the results</span>
    <span class="o">...</span>

    <span class="c1"># Let the model predict some more. In this call the workers are reused,</span>
    <span class="c1"># which means the big model doesn&#39;t need to be loaded again</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">...</span><span class="p">]])</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">model_predict</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># Workers are restarted in this case because the function changed</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">square_sum</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
<p>Instead of passing the flag to the <a class="reference internal" href="../reference/index.html#mpire.WorkerPool" title="mpire.WorkerPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mpire.WorkerPool</span></code></a> constructor you can also make use of
<a class="reference internal" href="../reference/index.html#mpire.WorkerPool.set_keep_alive" title="mpire.WorkerPool.set_keep_alive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpire.WorkerPool.set_keep_alive()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">WorkerPool</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">set_keep_alive</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map_unordered</span><span class="p">(</span><span class="n">square_sum</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="map.html" class="btn btn-neutral float-right" title="Map family" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Usage" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2024, Slimmer AI

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: v1.2.0
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../../v1.1.2/usage/setup.html">v1.1.2</a></dd>
            <dd><a href="../../v1.1.3/usage/setup.html">v1.1.3</a></dd>
            <dd><a href="setup.html">v1.2.0</a></dd>
            <dd><a href="../../v1.2.1/usage/setup.html">v1.2.1</a></dd>
            <dd><a href="../../v1.2.2/usage/setup.html">v1.2.2</a></dd>
            <dd><a href="../../v2.0.0/index.html">v2.0.0</a></dd>
            <dd><a href="../../v2.1.0/index.html">v2.1.0</a></dd>
            <dd><a href="../../v2.1.1/index.html">v2.1.1</a></dd>
            <dd><a href="../../v2.2.0/index.html">v2.2.0</a></dd>
            <dd><a href="../../v2.2.1/index.html">v2.2.1</a></dd>
            <dd><a href="../../v2.3.0/index.html">v2.3.0</a></dd>
            <dd><a href="../../v2.3.1/index.html">v2.3.1</a></dd>
            <dd><a href="../../v2.3.2/index.html">v2.3.2</a></dd>
            <dd><a href="../../v2.3.3/index.html">v2.3.3</a></dd>
            <dd><a href="../../v2.3.4/index.html">v2.3.4</a></dd>
            <dd><a href="../../v2.3.5/index.html">v2.3.5</a></dd>
            <dd><a href="../../v2.4.0/index.html">v2.4.0</a></dd>
            <dd><a href="../../v2.5.0/index.html">v2.5.0</a></dd>
            <dd><a href="../../v2.6.0/index.html">v2.6.0</a></dd>
            <dd><a href="../../v2.7.0/index.html">v2.7.0</a></dd>
            <dd><a href="../../v2.7.1/index.html">v2.7.1</a></dd>
            <dd><a href="../../v2.8.0/index.html">v2.8.0</a></dd>
            <dd><a href="../../v2.8.1/index.html">v2.8.1</a></dd>
            <dd><a href="../../v2.9.0/index.html">v2.9.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="../../dashboard-only-progress/index.html">dashboard-only-progress</a></dd>
            <dd><a href="../../exclude_tests_from_dists/index.html">exclude_tests_from_dists</a></dd>
            <dd><a href="../../master/index.html">master</a></dd>
        </dl>
    </div>
</div>


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>